回复用中文,



======== 前后端协同与开发阶段规划 ========

本项目采用 Codex（后端工程）优先、Gemini（前端 UI）并行原型 的开发模式，以保证系统的安全性、跨平台一致性与高效协作。开发流程分为三个主要阶段：

【阶段 1：Codex 主导（必须优先完成）】

Codex 在本阶段负责整个系统的基础安全模型、协议定义和业务核心逻辑的总体确定。具体产物如下：

1.1 安全体系与评估

建立完整的 E2EE 安全评估体系（评分 ≥ 98 分才可进入下一阶段）

明确威胁模型、攻击面、安全假设

确定 A→B 不可伪造的身份保证机制

确定群聊端对端加密方案

1.2 系统协议与数据结构

定义 mi_server / mi_client_E2EE 之间的通信协议

KCP 通道握手、认证、链路加密方案

登录流程（客户端 AES-256 加密密码 vs MySQL SHA-256）

A.json + 内层真实 JSON 的封装规范（包括蜜罐字段规则）

1.3 加密基础类型（必须先实现）

重写 C++ 基本类型（int/string/struct）为加密内存结构

标准化跨平台布局

提供 .dll / .so 可导出接口

编写文档《EncryptedBasicTypes.md》交付 Gemini 使用

1.4 API 文档（必须输出）

Codex 需完成：

bdtd.txt（后端全部业务 API 文档）

参数说明

返回值设计

错误码

异步/同步调用方式

DLL/so 初始化顺序

并提供给 Gemini 用于 UI 联调。

⚠ 在 Codex 完成此阶段之前，前端不得接业务逻辑，不得接入网络协议，不得尝试反向调用后端组件。

【阶段 2：Gemini 并行（仅限 UI 静态原型）】

在 Codex 进行阶段 1 的同时，Gemini 可以提前开展不含任何业务逻辑的 UI 原型开发，要求如下：

2.1 Windows UI（Electron / Qt）

100% 仿照 QQ 的 UI 布局、交互和视觉设计

使用苹果设计语言的图标与风格（简洁、统一色系、图标优先）

仅使用本地假数据（禁止写死后端结构）

所有组件必须能与未来的加密基础类型兼容

2.2 Android UI

不得使用虚幻引擎

使用开源免费的 UI 框架（Flutter / Qt / Jetpack Compose 均可）

同样仿照 QQ 的 UI，保持系统级一致性

使用假数据模拟聊天、联系人、群聊、文件列表等

2.3 前端产物

Gemini 需要提交：

UI 组件结构树

UI 交互流程

使用假数据实现的完整前端壳架构（不含逻辑）

Front-end_requirements.txt 初稿（向 Codex 列出需要补充的接口）

⚠ 此阶段严禁：

直接访问网络

调用后端 DLL/SO

存储真实数据

尝试对接加密协议

【阶段 3：正式联调（Codex 完成 API 后启动）】

Gemini 在 Codex 完成以下内容后，才能进入联调：

bdtd.txt（后端 API）

加密基础类型库（DLL/SO）

协议定稿

错误码与通信状态码

KCP 通道封装接口

群组/私聊加密 API

此阶段 Gemini 才能：

接入后端 DLL/SO

调用加密基础类型

发起真实 KCP 连接

加载真实聊天消息、文件传输数据

集成群聊 E2EE 加密

Codex 负责：

确保 API 稳定，不得随意更改参数

提供联调日志、调试版本 DLL/SO

负责协议落地实现与安全验证

【总结】

开发顺序要求如下：

必须先 Codex 完成安全模型 + 协议 + API（硬性要求）

Gemini 可以提前做静态 UI 原型（仅界面、不接业务）

等 Codex 输出 bdtd.txt 后，Gemini 才能开始正式联调

此策略能确保：

功能安全性不被 UI 牵着跑

UI 不耽误需求确定

前后端接口更清晰

项目整体开发效率最高


如果你是codex，那么请你用深度思考模型，仔细阅读完开发要求.txt,你是负责后端设计开发，和推送github，调用github actions构建,github 这些我已经配置好了
如果你是gemini,那么请你启用深度思考，仔细阅读完开发要求.txt，你是负责前端UI设计组件开发的


codex 和gemini 你们都需要通力合作，codex不需要写UI代码，gemini不需要写后端代码


开发软件:E2EE
支持平台:Windows Linux Android(需要跨平台)

开发语言:C C++ java js css html 
开发框架:openssl electron qt等UI主流框架

核心目标(优先级从-1到10，-1最高):
-1).程序运行速度最快
0).E2EE的各项安全性最高
1).程序效率最高
2).程序占用最低
3).编码风格采用微软程序员开发规范，一个函数只做一件事情，不同的业务封装在不同的类，不同的.dll里面
4).程序可靠性最强
5).程序大小最小

UI:
该部分有gemini实现，codex只需要提供好业务接口给Gemini做前端就可以了，服务器和客户端都是，
mi_server 和 mi_client_E2EE 客户端，(windows版本你负责将业务逻辑封装好在.dll程序，android封装在.so)
写好两个软件的前后端接口协议等，提供好给gemini进行开发前端UI
#########gemini阅读##############
UI需求:
1).如果是windows版本，那么请你百分百仿造QQ 的UI界面设计，如果是android版本，请你采用非虚幻引擎，采用别的开源免费的UI框架进行UI开发，一样仿照QQ的UI设计
2).除了服务器端的面板，客户端UI禁止设计成面板工具类型，必须采用苹果的设计语言，简洁易懂高效，UI组件能用图标，就不用文字，UI组件需要统一配色，背景颜色也需要进行统一
#########gemini阅读##############

数据库设计规范:
1).最小关联性
2).最大可靠性安全性
3).速度最快

数据结构设计规范:
1).数据结构紧凑
2).数据运行效率高
3).跨平台不影响

销毁文件流程:先获取文件大小->（如果过大，将文件/2，将文件头部，文件/2的位置，文件尾部，的0x10-0x100随机字节进行填写0xFF)->然后删除文件
                        ->(如果不大，直接暴力填入0xFF)

针对于文件，文档，影音视频:
1).服务器允许进行离线存储，但是离线存储，需要设计自己的算法，即服务器本地不会保存直接本地的文件，一般就是客户端已经加密好的，服务器只是让没有接受到过的客户，进行接收，如果一个群30个人，都收到过的，客户端对于该文件不进行保存，先对该文件进行全部填充为0XFF，彻底抹掉信息，之后再进行删除文件
2).客户端允许保存聊天记录，文档，文件，视频，影音资料等，但是都需要进行加密保存，格式采用自开发格式，只有用我们自己的客户端打开，才能打开，打开之前，文档，文件，视频，影音资料还需要对于当前用户是否是下载用户进行确认，如果不是，默认销毁文件，



mi_server:
1).基于MYSQL，做账号密码验证
2).和客户端建立KCP通道
3).对于客户端封包你只做投送给目标地址
4).开发面板
5).账号密码验证采用的是客户端用AES-256加密，明文是对比mysql数据库里面的sha-256看看是否比对的上





mi_client_E2EE：
1).用C++将全部C++需要用到的基本类型等进行重写加密
根据当前时间获取随机种子，假设如果是int类型=4字节,那么内存排序就是[1][2][3][4]这是明文保存方式，
那么当我们声明调用重写的int类型的时候，会根据时间种子，变成加密为16种中的一种，只有在printf 或者是需要传递到前端的时候才需要进行恢复，所以加密后假设是int 4字节类型 那么加密后就是打乱后的4字节+3-4个字节代表加密方式
这里需要单独封装成为一个基本数据类型,
注意因为开发的是C/S架构，所以你也要暴露告知Gemini 前端UI设计也要采用加密处理后的基本数据类型避免被黑客进行IDA分析出来
2).封装信息发送给目标客户端的时候需要采用如下流程:
本地客户端信息string类型->(解密恢复成原本的string类型)->消息采用json格式->采用的是目标客户端的公钥进行加密，加密算法:白盒AES-256-GCM->封装成A.json 之后再对A.json进行aes-256-gcm加密，采用的是B的公钥,当然，a.json里面的字段只是提供你理解，真实封装json的时候a.json的字段不能这样暴露给他人

######A.json#########
{
    #下面两个填写目标username,ip_port,username是要发送的目标的名称，但是ip_port，你就乱写，strings用随机数生成和加密后的real_message 一样长度的随机数据，然后也采用aes-256加密，得到的结果和加密后的real_message长度要一致，我要制造一个蜜罐给他
    username:
    ip_port:
    strings:
    message:存放真正的json
}
真正的json
{
    发信人的公钥:
    时间戳:
    消息:
}

3).需要深度思考，我们应该怎么样确保，A->B,不会变成A->C or C->B,信息被伪造，你需要默认服务器端不安全，但是她又是保存着用户登录信息的，也要要默认和你通信的对方可能不是真实要通信的人，你要思考，在跨平台的基础上，如何做到验证和你通信聊天的人就是那个人
4).群聊功能:即支持一个大群全部人聊天,全部聊天需要进行端对端的加密
5).在思考实现上面功能之前，你需要建立一个完整的安全评估体系，将你的想法列出，然后针对你的想法，通过联网和数据库知识库查询，对你的想法进行评估，满分100，安全系数只有达到98分才可以开始编码


前后端协调问题:
前端的开发必须规范，后端提供的API文档必须完善，且你的全部业务代码需要封装在(.dll/.so)，由前端编写的.exe/.apk进行调用，必须注意业务代码必须优先于UI加载

后端全部API:写在bdtd.txt里面，详细说明每一个参数返回值有什么用
前端的全部API和前端还需要后端提供什么:写在Front-end_requirements.txt里面
前端需要的依赖：写入Front-end_yl.txt里面
前端需要的依赖：写入end_yl.txt里面

/example 目录下有模板

github：
1).禁止推送build等目录,AGENTS.md/开发要求.txt/bdtd.txt/Front-end_requirements.txt/Front-end_yl.txt/end_yl.txt上去
2).必须默认采用的是github actions构建，假设有人github fork了我的仓库，他要fork之前需要填写服务器ip,端口，然后写入到服务器和客户端的代码里面去进行编译，客户得到的客户端是不用输入服务器ip和端口的，我这个的话，每次调用你就默认用127.0.0.1：19999端口
3).github actions构建,第一步是将(需要整合前后端依赖)全部需要的依赖全部拉取下来，如果想openssl没有预编译版本的，我们就现将全部依赖编译完成，后再进行我们的程序编译
4).如果要用到证书，默认在github actions构建,拉取编译完成全部依赖之后，再开始自签名证书，但是需要注意，证书不能外置，需要写入到编译源码里面，客户端出来不能携带证书，服务器也是
